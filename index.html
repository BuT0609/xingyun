<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ˜Ÿäº‘å¯„è¯­ - ç¹æ˜Ÿç‰ˆ</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Microsoft YaHei', sans-serif;
        }
        #canvas-container {
            width: 100%;
            height: 100vh;
            display: block;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #00ffff;
            font-size: 16px;
            pointer-events: none;
            letter-spacing: 2px;
            text-shadow: 0 0 10px #00ffff;
        }
    </style>
</head>
<body>
    <div id="loading">æ­£åœ¨åŠ è½½æµ©ç€šæ˜Ÿäº‘...</div>
    <div id="canvas-container"></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "@tweenjs/tween.js": "https://unpkg.com/@tweenjs/tween.js@23.1.1/dist/tween.esm.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import * as TWEEN from '@tweenjs/tween.js';

        // --- é…ç½®åŒºåŸŸ ---
        const config = {
            // ğŸ”¥ ä¿®æ”¹ç‚¹1ï¼šå¤§å¹…å¢åŠ å¡ç‰‡æ•°é‡ (ä»35æ”¹ä¸º80)
            cardCountPerTheme: 80, 
            hoverScale: 2.2,
            neighborRadius: 180,
            themeClustersSpread: 450,
        };

        const themes = [
            {
                name: "æš–å¿ƒé—®å€™",
                colorStart: "#FF0055", colorEnd: "#FF9900", 
                center: new THREE.Vector3(-config.themeClustersSpread, 0, 0),
                // ğŸ”¥ ä¿®æ”¹ç‚¹2ï¼šæ‰©å……è¯åº“ï¼Œé˜²æ­¢é‡å¤
                words: [
                    "äº‹äº‹é¡ºå¿ƒ", "ç¥ä½ å¹³å®‰", "è®°å¾—åƒé¥­", "æ—©ç‚¹ä¼‘æ¯", "åˆ«å¤ªç´¯äº†", "å¤©å¤©å¼€å¿ƒ", 
                    "å¥½è¿è¿è¿", "æ¸©æš–å¸¸åœ¨", "æˆ‘åœ¨å¬", "ä½ ä¸å­¤å•", "ä¸‡äº‹èƒœæ„", "å¹³å®‰å–œä¹", 
                    "å²å²å¹³å®‰", "å¤šå–çƒ­æ°´", "ç…§é¡¾å¥½è‡ªå·±", "æ‹¥æŠ±ä½ ", "åˆ«æ„Ÿå†’äº†", "å¿ƒæƒ…æ„‰æ‚¦", 
                    "ç¬‘å£å¸¸å¼€", "ä¸ç®¡ä¸é¡¾", "åªè¦å¿«ä¹", "ä½ è¦å¹¸ç¦", "æœ‰äººçˆ±ä½ ", "æ°¸è¿œå–„è‰¯",
                    "å¿ƒå‘é˜³å…‰", "æ— ç¾æ— éš¾", "é•¿å‘½ç™¾å²", "åƒå˜›å˜›é¦™", "ç¡ä¸ªå¥½è§‰", "å¥½è¿åŠ æ»¡"
                ]
            },
            {
                name: "è‡ªæˆ‘é¼“åŠ±",
                colorStart: "#0033FF", colorEnd: "#00FFFF", 
                center: new THREE.Vector3(config.themeClustersSpread, 120, -100),
                words: [
                    "ä½ å¾ˆæ£’", "åˆ«ç„¦è™‘", "æ…¢æ…¢æ¥", "ç›¸ä¿¡è‡ªå·±", "ä½ å¯ä»¥çš„", "æ‹’ç»å†…è€—", 
                    "æ‹¥æŠ±è‡ªå·±", "åšå›è‡ªå·±", "æ¸©æŸ”åšå®š", "ä¿æŒçƒ­çˆ±", "åˆå¿ƒæœªæ”¹", "è‡ªå¾‹è‡ªç”±", 
                    "å…‰èŠ’ä¸‡ä¸ˆ", "æœªæ¥å¯æœŸ", "å¥”èµ´å±±æµ·", "ç‹¬ä¸€æ— äºŒ", "é—ªé—ªå‘å…‰", "å‹‡æ•¢åšæ¢¦", 
                    "ç»ä¸è®¤è¾“", "é‡è›®ç”Ÿé•¿", "å¤§å™¨æ™šæˆ", "åšç§¯è–„å‘", "å‹‡å¾€ç›´å‰", "æ— æ‰€ç•æƒ§",
                    "å€¼å¾—æœ€å¥½", "ä»å®¹è‡ªä¿¡", "å†…å¿ƒå¼ºå¤§", "å¦‚æ„¿ä»¥å¿", "å¿…å®šä¸Šå²¸", "ç”±æ­¤å¯ç¨‹"
                ]
            },
            {
                name: "ç”Ÿæ´»æœŸè®¸",
                colorStart: "#00FF66", colorEnd: "#CCFF00",
                center: new THREE.Vector3(0, -config.themeClustersSpread, 100),
                words: [
                    "æ…¢æ…¢å˜å¥½", "ç”Ÿæ´»æ˜æœ—", "ä¸‡ç‰©å¯çˆ±", "æ¥æ—¥æ–¹é•¿", "è«è´ŸéŸ¶å", "å‰ç¨‹ä¼¼é”¦", 
                    "è´¢æºæ»šæ»š", "å¿ƒæƒ³äº‹æˆ", "é‡è§ç¾å¥½", "é‡æ–°å¼€å§‹", "ä¸€åˆ‡é¡ºåˆ©", "å¥½æ¢¦", 
                    "äº«å—å½“ä¸‹", "æœªæ¥æ˜¯æˆ‘", "è¿™å°±æ˜¯æˆ‘", "å¥½äº‹å‘ç”Ÿ", "é”¦é²¤é™„ä½“", "æš´å¯Œæš´ç˜¦", 
                    "æ—¥è¿›æ–—é‡‘", "èŠ±å¼€å¯Œè´µ", "è’¸è’¸æ—¥ä¸Š", "æ­¥æ­¥é«˜å‡", "å¾—å¿æ‰€æ„¿", "çš†å¤§æ¬¢å–œ",
                    "é›¨è¿‡å¤©æ™´", "å¦ææ³°æ¥", "é¡ºé£é¡ºæ°´", "æ»¡å¿ƒæ¬¢å–œ", "ä¸è´Ÿæ­¤ç”Ÿ", "å¦‚çº¦è€Œè‡³"
                ]
            }
        ];

        let camera, scene, renderer, controls;
        let raycaster, mouse;
        let hoveredCard = null;
        const allCards = [];
        const starParticles = [];

        init();
        animate();

        function init() {
            const container = document.getElementById('canvas-container');
            document.getElementById('loading').style.display = 'none';

            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.0003);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 5000);
            camera.position.set(0, 0, 1400); // ç¨å¾®æ‹‰è¿œä¸€ç‚¹ç›¸æœºï¼Œå› ä¸ºå¡ç‰‡å˜å¤šäº†

            const ambientLight = new THREE.AmbientLight(0xffffff, 2.5);
            scene.add(ambientLight);
            
            const light1 = new THREE.PointLight(0xff00ff, 3, 2000); 
            light1.position.set(500, 500, 500);
            scene.add(light1);
            
            const light2 = new THREE.PointLight(0x00ffff, 3, 2000);
            light2.position.set(-500, -500, 800);
            scene.add(light2);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.toneMapping = THREE.NoToneMapping; 
            
            container.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 0.3;
            controls.enablePan = false;

            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            window.addEventListener('mousemove', onMouseMove);
            window.addEventListener('resize', onWindowResize);

            createStarField();
            createAllCards();
        }

        function createStarField() {
            const geometry = new THREE.BufferGeometry();
            const vertices = [];
            for (let i = 0; i < 5000; i++) { // ç¨å¾®å¢åŠ ä¸€ç‚¹èƒŒæ™¯æ˜Ÿæ˜Ÿ
                vertices.push(
                    THREE.MathUtils.randFloatSpread(5000),
                    THREE.MathUtils.randFloatSpread(5000),
                    THREE.MathUtils.randFloatSpread(5000)
                );
            }
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            const material = new THREE.PointsMaterial({ color: 0xffffff, size: 2.5, transparent: true, opacity: 0.9 });
            const stars = new THREE.Points(geometry, material);
            scene.add(stars);
            starParticles.push(stars);
        }

        function createCardTexture(text, colorStart, colorEnd) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 512;
            canvas.height = 256;

            const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
            gradient.addColorStop(0, colorStart);
            gradient.addColorStop(1, colorEnd);

            ctx.fillStyle = gradient;
            ctx.globalAlpha = 0.92; 
            
            roundRect(ctx, 10, 10, canvas.width - 20, canvas.height - 20, 40, true, false);

            ctx.globalAlpha = 1.0;
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 85px "Microsoft YaHei"'; 
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.shadowColor = 'rgba(0, 0, 0, 1.0)';
            ctx.shadowBlur = 10;
            ctx.shadowOffsetX = 4;
            ctx.shadowOffsetY = 4;
            ctx.fillText(text, canvas.width / 2, canvas.height / 2);

            ctx.strokeStyle = 'rgba(255,255,255,0.8)';
            ctx.lineWidth = 8;
            roundRect(ctx, 10, 10, canvas.width - 20, canvas.height - 20, 40, false, true);

            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            return texture;
        }
        
        function roundRect(ctx, x, y, width, height, radius, fill, stroke) {
            if (typeof stroke === 'undefined') { stroke = true; }
            if (typeof radius === 'undefined') { radius = 5; }
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + width - radius, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
            ctx.lineTo(x + width, y + height - radius);
            ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
            ctx.lineTo(x + radius, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
            ctx.lineTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y);
            ctx.closePath();
            if (fill) { ctx.fill(); }
            if (stroke) { ctx.stroke(); }
        }

        function createAllCards() {
            themes.forEach(theme => {
                for (let i = 0; i < config.cardCountPerTheme; i++) {
                    const text = theme.words[i % theme.words.length];
                    const texture = createCardTexture(text, theme.colorStart, theme.colorEnd);

                    const material = new THREE.MeshPhysicalMaterial({
                        map: texture,
                        transparent: true,
                        side: THREE.DoubleSide,
                        emissive: 0xffffff,       
                        emissiveMap: texture,     
                        emissiveIntensity: 0.8,   
                        opacity: 1.0,             
                        metalness: 0.2, 
                        roughness: 0.1,
                        clearcoat: 1.0,           
                        clearcoatRoughness: 0.1
                    });

                    const geometry = new THREE.PlaneGeometry(160, 80);
                    const card = new THREE.Mesh(geometry, material);

                    // ğŸ”¥ ä¿®æ”¹ç‚¹3ï¼šæ‰©å¤§åˆ†å¸ƒåŠå¾„ï¼Œè®©æ›´å¤šçš„å¡ç‰‡æœ‰ç©ºé—´å±•ç¤º
                    // æ—§å€¼: 200 + Math.random() * 250
                    // æ–°å€¼: 220 + Math.random() * 380
                    const radius = 220 + Math.random() * 380;
                    
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    
                    card.position.set(
                        theme.center.x + radius * Math.sin(phi) * Math.cos(theta),
                        theme.center.y + radius * Math.sin(phi) * Math.sin(theta),
                        theme.center.z + radius * Math.cos(phi)
                    );

                    card.lookAt(new THREE.Vector3(0,0,0)); 
                    card.rotation.z = Math.random() * 0.5 - 0.25; 

                    card.userData.initialPosition = card.position.clone();
                    card.userData.initialRotation = card.rotation.clone();
                    card.userData.initialScale = card.scale.clone();
                    card.userData.floatSpeed = 0.0005 + Math.random() * 0.001;
                    card.userData.floatOffset = Math.random() * 100;

                    scene.add(card);
                    allCards.push(card);
                }
            });
        }

        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function updateInteraction() {
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(allCards);

            if (intersects.length > 0) {
                const targetCard = intersects[0].object;

                if (hoveredCard !== targetCard) {
                    if (hoveredCard) resetCard(hoveredCard);
                    hoveredCard = targetCard;
                    focusCard(hoveredCard);
                    affectNeighbors(hoveredCard);
                    controls.autoRotate = false; 
                    document.body.style.cursor = 'pointer';
                }
            } else {
                if (hoveredCard) {
                    resetCard(hoveredCard);
                    resetNeighbors();
                    hoveredCard = null;
                    controls.autoRotate = true;
                    document.body.style.cursor = 'default';
                }
            }
        }

        function focusCard(card) {
            new TWEEN.Tween(card.scale)
                .to({ x: config.hoverScale, y: config.hoverScale, z: config.hoverScale }, 300)
                .easing(TWEEN.Easing.Back.Out)
                .start();
            
            new TWEEN.Tween(card.material)
                .to({ emissiveIntensity: 2.0 }, 300) 
                .start();

            card.lookAt(camera.position); 
        }

        function resetCard(card) {
            new TWEEN.Tween(card.scale)
                .to(card.userData.initialScale, 400)
                .easing(TWEEN.Easing.Quadratic.InOut)
                .start();
            
            new TWEEN.Tween(card.material)
                .to({ emissiveIntensity: 0.8 }, 400) 
                .start();
             
            new TWEEN.Tween(card.rotation)
                .to({ x: card.userData.initialRotation.x, y: card.userData.initialRotation.y, z: card.userData.initialRotation.z }, 600)
                .start();
        }

        function affectNeighbors(centerCard) {
            allCards.forEach(card => {
                if (card === centerCard) return;
                const dist = card.position.distanceTo(centerCard.position);
                if (dist < config.neighborRadius) {
                    const dir = card.position.clone().sub(centerCard.position).normalize();
                    const force = (config.neighborRadius - dist) * 0.8; 
                    const targetPos = card.userData.initialPosition.clone().add(dir.multiplyScalar(force));

                    new TWEEN.Tween(card.position).to(targetPos, 400).easing(TWEEN.Easing.Cubic.Out).start();
                    new TWEEN.Tween(card.material).to({ opacity: 0.3, emissiveIntensity: 0.2 }, 400).start();
                } else {
                      new TWEEN.Tween(card.material).to({ opacity: 0.8, emissiveIntensity: 0.5 }, 400).start();
                }
            });
        }

        function resetNeighbors() {
            allCards.forEach(card => {
                if (card === hoveredCard) return;
                new TWEEN.Tween(card.position).to(card.userData.initialPosition, 600).easing(TWEEN.Easing.Cubic.InOut).start();
                new TWEEN.Tween(card.material).to({ opacity: 1.0, emissiveIntensity: 0.8 }, 600).start();
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            TWEEN.update();
            updateInteraction();
            controls.update();

            const time = Date.now();
            starParticles.forEach(p => p.rotation.y += 0.0001);
            
            allCards.forEach(card => {
                if (card !== hoveredCard) {
                    card.position.y += Math.sin(time * card.userData.floatSpeed + card.userData.floatOffset) * 0.1;
                }
            });

            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
